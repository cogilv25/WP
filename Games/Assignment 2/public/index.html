<!DOCTYPE html>
<html>
	<head>
		<title>The Tower</title>
		<link rel="stylesheet" href="normalize.css">
		<link rel="stylesheet" href="style.css">
		<script src="/socket.io/socket.io.js"></script>
		<script src="https://code.createjs.com/1.0.0/easeljs.min.js"></script>
		<script src="keyboard.js"></script>
	</head>
	<body style="display: flex; flex-direction: column">
		<div id="main_menu">
			<div id="auth_view">
				<form id="auth_form">
					<h1> <span id="login_button" class="auth_selected">Login</span> or <span id="register_button" class="auth_unselected">Register</span></h1>
					<input id="username" type="text" autocomplete="off" placeholder="Username" maxlength="32">
					<input id="password" type="password" placeholder="Password" maxlength="32">
					<button style="width: 155px" id="auth_button" type="submit">Login</button>
				</form>
			</div>
			<div id="lobby_view" style="display: none;">
				<h1> Join or Create a Lobby </h1>
				<div id="lobbies"></div>
				<div id="lobby_creator_area">
					<div id="lobby_creator_transition"></div>
					<div id="lobby_creator_container">
						<form id="lobby_creator">
							<input id="lobby_name" autocomplete="off" maxlength=20>
							<div id="vr"></div>
							<button id="create_lobby" type="submit">Create Lobby</button>
						</form>
					</div>
				</div>
			</div>
		</div>
		<div id="game_view" style="display: none;">
			<canvas id="canvas" width="800" height="600"></canvas>
		</div>
		<script>
			// Pass these over when first connecting or via XHR..?
			var entityTypes = [];
			entityTypes['ball'] = 
			{
				density: 0.5,
				friction: 0.5,
				restitution: 0.5,
				x: 0, y:0,
				rotation: 0,
				radius: 10,
				type: "dynamic",
				shape: "circle"
			};
			entityTypes['wall'] = 
			{
				density: 0.5,
				friction: 0.5,
				restitution: 0.5,
				x: 0, y: 0,
				rotation: 0,
				width: 8,
				height: 600,
				type: "static",
				shape: "rect"
			};
			entityTypes['floor'] = 
			{
				density: 0.5,
				friction: 0.5,
				restitution: 0.5,
				x: 0, y: 0,
				rotation: 0,
				width: 800,
				height: 8,
				type: "static",
				shape: "rect"
			};

			entityTypes['player'] = 
			{

				density: 0.5,
				friction: 0.5,
				restitution: 0.0,
				x: 400, y: 300,
				rotation: 0,
				width: 32,
				height: 64,
				type: "dynamic",
				shape: "rect"
			};

			// Max value is 63 since we are using the 7th and 8th bits for
			//    representing the player and input state.
			let inputMap = 
			{
				up:    0,
				left:  1,
				right: 2,
				down:  3,
				jump:  4
			};

			let stage;
			let entities = [];

			let gameStarted = false;
			let lobbies = [];
			let socket = io();
			socket.on("connect", () => {
				console.log(socket.id);
			});

			let lc = document.getElementById("lobby_creator");
			let ln = document.getElementById("lobby_name");
			let lv = document.getElementById("lobby_view");
			let createLobbyButton = document.getElementById("create_lobby");
			let mainMenu = document.getElementById("main_menu");
			let gameView = document.getElementById("game_view");
			let canvas = document.getElementById("canvas");
			let loginButton = document.getElementById("login_button");
			let registerButton = document.getElementById("register_button");
			let authView = document.getElementById("auth_view");
			let authForm = document.getElementById("auth_form");
			let authButton = document.getElementById("auth_button");
			let username = document.getElementById("username");
			let password = document.getElementById("password");

			let lastTick = performance.now();

			let loginFormEvent = "login";

			window.addEventListener("load", ()=>
				{
					initializeKeyboard(
						{
							up:    [87, 38],
							left:  [65, 37],
							right: [68, 39],
							down:  [83, 40],
							jump:  [32]
						}, false
					);
					registerUniversalKeyboardCallback("edge", (input, state) =>
					{
						if(gameStarted)
						{
							socket.emit("input", inputMap[input] + (state ? 128 : 0));
						}
					});
				});
			

			loginButton.addEventListener("click", () =>
				{
					loginButton.classList.add("auth_selected");
					loginButton.classList.remove("auth_unselected");
					registerButton.classList.add("auth_unselected");
					registerButton.classList.remove("auth_selected");
					loginFormEvent = "login";
					authButton.textContent = "Login";
				});

			registerButton.addEventListener("click", () =>
				{
					registerButton.classList.add("auth_selected");
					registerButton.classList.remove("auth_unselected");
					loginButton.classList.add("auth_unselected");
					loginButton.classList.remove("auth_selected");
					loginFormEvent = "register";
					authButton.textContent = "Register";
				});

			authForm.addEventListener("animationend", () =>
				{
					authForm.classList.remove("invalid_login");
				});

			username.addEventListener("keypress", () =>
				{
					if(username.value.length == username.maxLength)
					{
						authForm.classList.add("invalid_login");
					}
				});

			password.addEventListener("keypress", () =>
				{
					if(password.value.length == password.maxLength)
					{
						authForm.classList.add("invalid_login");
					}
				});

			authForm.addEventListener("submit", (e) =>
				{
					e.preventDefault();
					if(username.value.length < 5 || password.value.length < 5)
					{
						// TODO: notification
						authForm.classList.add("invalid_login");
						return;
					}
					socket.emit(loginFormEvent, 
						{
							username: username.value,
							password: password.value
						});
				});

			let lobbyList = document.getElementById("lobbies");
			ln.addEventListener("keypress", () =>
				{
					if(ln.value.length == ln.maxLength)
					{
						lc.classList.add("invalid_lobby");
					}
				});
			lc.addEventListener("animationend", () => 
				{
					lc.classList.remove("invalid_lobby"); 
				});

			lc.addEventListener("submit", (e) => 
				{
					e.preventDefault();
					if(ln.value.length < 5)
					{
						lc.classList.add("invalid_lobby");
						return;
					}

					socket.emit("create_lobby", ln.value);
					ln.value = "";
				});

			function renderLobbies()
			{
				lobbyList.textContent = "";
				for(let i = 0; i < lobbies.length; ++i)
				{
					let l = document.createElement("div");
					l.classList.add("lobby");
					l.textContent = lobbies[i].name;
					let s = document.createElement("span");
					s.textContent = "(" + lobbies[i].players.length + " / 2)";
					l.appendChild(s);
					l.addEventListener("click", () => 
						{
							joinLobby(i);
						});
					lobbyList.appendChild(l);
				}
			}

			function createEntity(props)
			{
				let g = new createjs.Graphics();
				g.setStrokeStyle(1);
				let rx,ry;
				if(props.shape == "circle")
				{
					g.beginStroke(createjs.Graphics.getRGB(0,0,0));
					g.beginFill(createjs.Graphics.getRGB(255,0,0));
					g.drawCircle(0, 0, props.radius);
					rx = 0;
					ry = rx;
				}
				else
				{
					g.beginStroke(createjs.Graphics.getRGB(0,0,0));
					g.beginFill(createjs.Graphics.getRGB(0,0,255));
					g.rect(0, 0, props.width, props.height);
					rx = props.width / 2;
					ry = props.height / 2;
				}

				let s = new createjs.Shape(g);
				s.regX = rx;
				s.regY = ry;
				s.x = props.x;
				s.y = props.y;

				stage.addChild(s);
				stage.update();
				return s;
			}

			function initializeWorld(state)
			{
				for(let i = 0; i < state.length; ++i)
				{
					let template = state[i];
					let props = structuredClone(entityTypes[template.game_type]);
					for([k, v] of Object.entries(template))
					{
						props[k] = v;
					}
					entities.push(createEntity(props));
				}
			}

			function joinLobby(index)
			{
				socket.emit("join_lobby", lobbies[index].name);
			}


			socket.on("joined_world", (state) =>
				{
					initializeWorld(state);
					mainMenu.style.display = "none";
					gameView.style.display = "flex";
					gameStarted = true;
				});

			socket.on("logged_in", (remoteLobbies) =>
				{
					console.log("Logged In!");
					lv.style.display = "flex";
					authView.style.display = "none";
					lobbies = remoteLobbies;
					renderLobbies();
				});

			socket.on("invalid_login", (error) =>
				{
					// TODO: notifications top-right
					console.error(error);
				});

			socket.on("lobby_dissolve", (lobby) => 
				{
					lobbies.splice(lobbies.findIndex(
						(a) => { return a.name === lobby.name; })
					, 1);
					renderLobbies();
				});

			socket.on("lobby_update", (lobby) =>
				{
					lobbies[lobbies.findIndex(
						(a) => { return a.name === lobby.name; }
					)] = lobby;
					renderLobbies();
				});

			socket.on("u", (update) =>
			{
				if(!gameStarted) return;
				//console.log(update);

				let delta = performance.now() - lastTick;
				console.log(1000 / delta);
				lastTick = performance.now();

				let buffer = new Uint16Array(update);
				// No Point in updating the stage unless
				//    there's something to update!
				for(let i = 0; i < buffer.length / 4; ++i)
				{
					let id = buffer[i * 4];
					entities[id].x = buffer[i * 4 + 1];
					entities[id].y = buffer[i * 4 + 2];
					entities[id].rotation = buffer[i * 4 + 3] / (65536 / 360);
				}
				stage.update();
			});

			socket.on("player_joined", (player) =>
				{
					
				});

			socket.on("invalid_lobby", (message) =>
				{
					lc.classList.add("invalid_lobby");
					console.log(message);
				});

			socket.on("lobby_created", (lobby) =>
				{
					lobbies.push(lobby);
					renderLobbies();
				});


			socket.on("lobby_list", (newLobbies) =>
				{
					lobbies = newLobbies;
					renderLobbies();
				});

			stage = new createjs.Stage(canvas);
			stage.snapPixelsEnabled = true;
		</script>
	</body>
</html>